import { Range } from '../types';
import { BaseApi } from './Base';
export interface BufferSetLines {
    start?: number;
    end?: number;
    strictIndexing?: boolean;
}
export interface BufferHighlight {
    hlGroup?: string;
    line?: number;
    colStart?: number;
    colEnd?: number;
    srcId?: number;
}
export interface BufferClearHighlight {
    srcId?: number;
    lineStart?: number;
    lineEnd?: number;
}
export interface SignPlaceOption {
    id?: number;
    group?: string;
    name: string;
    lnum: number;
    priority?: number;
}
export interface SignUnplaceOption {
    group?: string;
    id?: number;
}
export interface SignPlacedOption {
    group?: string;
    id?: number;
    lnum?: number;
}
export interface SignItem {
    group: string;
    id: number;
    lnum: number;
    name: string;
    priority: number;
}
export interface HighlightItem {
    hlGroup: string;
    /**
     * 0 based
     */
    lnum: number;
    /**
     * 0 based
     */
    colStart: number;
    /**
     * 0 based
     */
    colEnd: number;
}
export interface KeymapOption {
    nowait?: boolean;
    silent?: boolean;
    script?: boolean;
    expr?: boolean;
    unique?: boolean;
}
export interface Disposable {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare type Chunk = [string, string];
export declare class Buffer extends BaseApi {
    prefix: string;
    /**
     * Attach to buffer to listen to buffer events
     * @param sendBuffer Set to true if the initial notification should contain
     *        the whole buffer. If so, the first notification will be a
     *        `nvim_buf_lines_event`. Otherwise, the first notification will be
     *        a `nvim_buf_changedtick_event`
     */
    attach(sendBuffer?: boolean, options?: {}): Promise<boolean>;
    /**
     * Detach from buffer to stop listening to buffer events
     */
    detach(): Promise<boolean>;
    /**
     * Get the bufnr of Buffer
     */
    get id(): number;
    /** Total number of lines in buffer */
    get length(): Promise<number>;
    /** Get lines in buffer */
    get lines(): Promise<string[]>;
    /** Gets a changed tick of a buffer */
    get changedtick(): Promise<number>;
    get commands(): Promise<Object>;
    getCommands(options?: {}): Promise<Object>;
    /** Get specific lines of buffer */
    getLines({ start, end, strictIndexing }?: {
        start: number;
        end: number;
        strictIndexing: boolean;
    }): Promise<string[]>;
    /** Set lines of buffer given indeces */
    setLines(_lines: string | string[], { start: _start, end: _end, strictIndexing }?: BufferSetLines, notify?: boolean): void | Promise<any>;
    /**
     * Set virtual text for a line
     *
     * @public
     * @param {number} src_id - Source group to use or 0 to use a new group, or -1
     * @param {number} line - Line to annotate with virtual text (zero-indexed)
     * @param {Chunk[]} chunks - List with [text, hl_group]
     * @param {{[index} opts
     * @returns {Promise<number>}
     */
    setVirtualText(src_id: number, line: number, chunks: Chunk[], opts?: {
        [index: string]: any;
    }): Promise<number>;
    /** Insert lines at `start` index */
    insert(lines: string[] | string, start: number): void | Promise<any>;
    /** Replace lines starting at `start` index */
    replace(_lines: string[] | string, start: number): void | Promise<any>;
    /** Remove lines at index */
    remove(start: number, end: number, strictIndexing?: boolean): void | Promise<any>;
    /** Append a string or list of lines to end of buffer */
    append(lines: string[] | string): void | Promise<any>;
    /** Get buffer name */
    get name(): Promise<string>;
    /** Set current buffer name */
    setName(value: string): Promise<void>;
    /** Is current buffer valid */
    get valid(): Promise<boolean>;
    /** Get mark position given mark name */
    mark(name: string): Promise<[number, number]>;
    /** Gets keymap */
    getKeymap(mode: string): Promise<object[]>;
    /**
     * Add keymap by notification.
     */
    setKeymap(mode: string, lhs: string, rhs: string, opts?: KeymapOption): void;
    /**
   * Checks if a buffer is valid and loaded. See |api-buffer| for
   * more info about unloaded buffers.
   */
    get loaded(): Promise<boolean>;
    /**
     * Returns the byte offset for a line.
     *
     * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
     * one byte. 'fileformat' and 'fileencoding' are ignored. The
     * line index just after the last line gives the total byte-count
     * of the buffer. A final EOL byte is counted if it would be
     * written, see 'eol'.
     *
     * Unlike |line2byte()|, throws error for out-of-bounds indexing.
     * Returns -1 for unloaded buffer.
     *
     * @return {Number} Integer byte offset, or -1 for unloaded buffer.
     */
    getOffset(index: number): Promise<number>;
    /**
      Adds a highlight to buffer.
  
      This can be used for plugins which dynamically generate
      highlights to a buffer (like a semantic highlighter or
      linter). The function adds a single highlight to a buffer.
      Unlike matchaddpos() highlights follow changes to line
      numbering (as lines are inserted/removed above the highlighted
      line), like signs and marks do.
  
      "src_id" is useful for batch deletion/updating of a set of
      highlights. When called with src_id = 0, an unique source id
      is generated and returned. Succesive calls can pass in it as
      "src_id" to add new highlights to the same source group. All
      highlights in the same group can then be cleared with
      nvim_buf_clear_highlight. If the highlight never will be
      manually deleted pass in -1 for "src_id".
  
      If "hl_group" is the empty string no highlight is added, but a
      new src_id is still returned. This is useful for an external
      plugin to synchrounously request an unique src_id at
      initialization, and later asynchronously add and clear
      highlights in response to buffer changes. */
    addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }: BufferHighlight): Promise<number | null>;
    /**
     * Clear highlights of specified lins.
     *
     * @deprecated use clearNamespace instead.
     */
    clearHighlight(args?: BufferClearHighlight): void;
    /**
     * Add highlight to ranges by notification.
     *
     * @param {string | number} srcId Unique key or namespace number.
     * @param {string} hlGroup Highlight group.
     * @param {Range[]} ranges List of highlight ranges
     */
    highlightRanges(srcId: string | number, hlGroup: string, ranges: Range[]): void;
    /**
     * Clear namespace by id or name.
     *
     * @param key Unique key or namespace number, use -1 for all namespaces
     * @param lineStart Start of line, 0 based, default to 0.
     * @param lineEnd End of line, 0 based, default to -1.
     */
    clearNamespace(key: number | string, lineStart?: number, lineEnd?: number): void;
    /**
     * Add sign to buffer by notification.
     *
     * @param {SignPlaceOption} sign
     * @returns {void}
     */
    placeSign(sign: SignPlaceOption): void;
    /**
     * Unplace signs by notification
     */
    unplaceSign(opts: SignUnplaceOption): void;
    /**
     * Get signs by group name or id and lnum.
     *
     * @param {SignPlacedOption} opts
     * @returns {Promise<SignItem[]>}
     */
    getSigns(opts: SignPlacedOption): Promise<SignItem[]>;
    /**
     * Get highlight items by name space (end exclusive).
     *
     * @param {string | number} ns Namespace key or id.
     * @param {number} start 0 based line number.
     * @param {number} end 0 based line number.
     * @returns {Promise<HighlightItem[]>}
     */
    getHighlights(ns: string | number, start?: number, end?: number): Promise<HighlightItem[]>;
    /**
     * Update highlight items by notification.
     *
     * @param {string | number} ns Namespace key or id.
     * @param {HighlightItem[]} highlights Highlight items.
     * @param {number} start 0 based line number.
     * @param {number} end 0 based line number.
     * @returns {void}
     */
    updateHighlights(ns: string | number, highlights: HighlightItem[], start?: number, end?: number): void;
    /**
     * Listens to buffer for events
     */
    listen(eventName: string, cb: Function, disposables?: Disposable[]): void;
}
export {};
