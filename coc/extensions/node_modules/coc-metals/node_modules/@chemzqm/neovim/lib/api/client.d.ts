/// <reference types="node" />
import { Logger } from '../types';
import { Neovim } from './Neovim';
import { Buffer } from './Buffer';
import { Window } from './Window';
import { Tabpage } from './Tabpage';
export declare type Callback = (err?: Error | null, res?: any) => void;
export declare class AsyncResponse {
    readonly requestId: number;
    private cb;
    private finished;
    constructor(requestId: number, cb: Callback);
    finish(err?: string | null, res?: any): void;
}
export declare class NeovimClient extends Neovim {
    private logger;
    private _isReady;
    private requestId;
    private transportAttached;
    private responses;
    private _channelId;
    private attachedBuffers;
    private functions;
    constructor(logger: Logger);
    echoError(msg: string | Error): void;
    logError(msg: string, ...args: any[]): void;
    createBuffer(id: number): Buffer;
    createWindow(id: number): Window;
    createTabpage(id: number): Tabpage;
    send(arr: any[]): void;
    /**
     * Invoke redraw on vim.
     */
    redrawVim(force?: boolean): void;
    /** Attaches msgpack to read/write streams * */
    attach({ reader, writer, }: {
        reader: NodeJS.ReadableStream;
        writer: NodeJS.WritableStream;
    }, requestApi?: boolean): void;
    detach(): void;
    get isApiReady(): boolean;
    get channelId(): Promise<number>;
    isAttached(bufnr: number): boolean;
    private handleRequest;
    sendAsyncRequest(method: string, args: any[]): Promise<any>;
    private emitNotification;
    private handleNotification;
    private setupTransport;
    requestApi(): Promise<any[]>;
    private generateApi;
    attachBufferEvent(buffer: Buffer, eventName: string, cb: Function): void;
    /**
     * Returns `true` if buffer should be detached
     */
    detachBufferEvent(buffer: Buffer, eventName: string, cb: Function): void;
    pauseNotification(): void;
    resumeNotification(cancel?: boolean, notify?: boolean): Promise<any>;
    hasFunction(name: string): boolean;
}
